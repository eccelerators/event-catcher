-- Copyright (C) 2024 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler v0.0.0-0000000
-- VHDL Extension for HxS 1.0.21-b962bd24
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.EventCatcherIfcPackage.all;

entity EventCatcherBlk_EventCatcherIfc is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Address : in std_logic_vector(3 downto 0);
		ByteEnable : in std_logic_vector(3 downto 0);
		Read : in std_logic;
		ReadData : out std_logic_vector(31 downto 0);
		Write : in std_logic;
		WriteData : in std_logic_vector(31 downto 0);
		WaitRequest : out std_logic;
		Match : out std_logic;
		Mask : out std_logic_vector(3 downto 0);
		CatchToBeRead : in std_logic_vector(3 downto 0);
		CatchWritten : out std_logic_vector(3 downto 0);
		WTransPulseEventCatchReg : out std_logic;
		OverrunToBeRead : in std_logic_vector(3 downto 0);
		OverrunWritten : out std_logic_vector(3 downto 0);
		WTransPulseEventOverrunReg : out std_logic
	);
end;

architecture Behavioural of EventCatcherBlk_EventCatcherIfc is

	signal PreReadData : std_logic_vector(31 downto 0);
	
	signal PreReadDataEventMaskReg : std_logic_vector(31 downto 0);
	signal PreReadAckEventMaskReg : std_logic;
	signal ReadDiffEventMaskReg : std_logic;
	signal PreWriteAckEventMaskReg : std_logic;
	signal WriteDiffEventMaskReg : std_logic;
	signal WRegMask : std_logic_vector(3 downto 0);
	signal PreMatchReadEventMaskReg : std_logic;
	signal PreMatchWriteEventMaskReg : std_logic;
	
	signal PreReadDataEventCatchReg : std_logic_vector(31 downto 0);
	signal PreReadAckEventCatchReg : std_logic;
	signal ReadDiffEventCatchReg : std_logic;
	signal PreWriteAckEventCatchReg : std_logic;
	signal WriteDiffEventCatchReg : std_logic;
	signal PreMatchReadEventCatchReg : std_logic;
	signal PreMatchWriteEventCatchReg : std_logic;
	
	signal PreReadDataEventOverrunReg : std_logic_vector(31 downto 0);
	signal PreReadAckEventOverrunReg : std_logic;
	signal ReadDiffEventOverrunReg : std_logic;
	signal PreWriteAckEventOverrunReg : std_logic;
	signal WriteDiffEventOverrunReg : std_logic;
	signal PreMatchReadEventOverrunReg : std_logic;
	signal PreMatchWriteEventOverrunReg : std_logic;

begin

	ReadData <= PreReadData;
	
	Match <= PreMatchReadEventMaskReg or PreMatchWriteEventMaskReg
		  or PreMatchReadEventCatchReg or PreMatchWriteEventCatchReg
		  or PreMatchReadEventOverrunReg or PreMatchWriteEventOverrunReg;
	
	WaitRequest <= not (PreReadAckEventMaskReg or PreWriteAckEventMaskReg
		or PreReadAckEventCatchReg or PreWriteAckEventCatchReg
		or PreReadAckEventOverrunReg or PreWriteAckEventOverrunReg);
	
	PreDatOutMux: process (
		PreReadDataEventMaskReg,
		PreMatchReadEventMaskReg,
		PreReadAckEventMaskReg,
		PreReadDataEventCatchReg,
		PreMatchReadEventCatchReg,
		PreReadAckEventCatchReg,
		PreReadDataEventOverrunReg,
		PreMatchReadEventOverrunReg,
		PreReadAckEventOverrunReg
	) begin
		PreReadData <= (others => '0');
		if (PreMatchReadEventMaskReg = '1' and PreReadAckEventMaskReg = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataEventMaskReg), PreReadData'LENGTH));
		elsif (PreMatchReadEventCatchReg = '1' and PreReadAckEventCatchReg = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataEventCatchReg), PreReadData'LENGTH));
		elsif (PreMatchReadEventOverrunReg = '1' and PreReadAckEventOverrunReg = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataEventOverrunReg), PreReadData'LENGTH));
		end if;
	end process;
	
	PreMatchReadEventMaskRegProcess : process (Address, Read)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTMASKREG_ADDRESS)) then
			PreMatchReadEventMaskReg <= Read;
		else
			PreMatchReadEventMaskReg <= '0';
		end if;
	end process;
	
	PreMatchWriteEventMaskRegProcess : process (Address, Write)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTMASKREG_ADDRESS)) then
			PreMatchWriteEventMaskReg <= Write;
		else
			PreMatchWriteEventMaskReg <= '0';
		end if;
	end process;
	
	WriteDiffEventMaskRegProcess : process (Address, Write, PreWriteAckEventMaskReg)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTMASKREG_ADDRESS)) then
			WriteDiffEventMaskReg <=  Write and not PreWriteAckEventMaskReg;
		else
			WriteDiffEventMaskReg <= '0';
		end if;
	end process;
	
	ReadDiffEventMaskRegProcess : process (Address, Read, PreReadAckEventMaskReg)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTMASKREG_ADDRESS)) then
			ReadDiffEventMaskReg <= Read and not PreReadAckEventMaskReg;
		else
			ReadDiffEventMaskReg <= '0';
		end if;
	end process;
	
	SyncPartEventMaskReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckEventMaskReg <= '0';
			PreWriteAckEventMaskReg <= '0';
			WRegMask <= EVENTENABLED;
		elsif rising_edge(Clk) then
			PreWriteAckEventMaskReg <= WriteDiffEventMaskReg;
			PreReadAckEventMaskReg <= ReadDiffEventMaskReg;
			if (WriteDiffEventMaskReg = '1') then
				if (ByteEnable(0) = '1') then WRegMask(3 downto 0) <= WriteData(3 downto 0); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxForEventMaskReg : process (
		WRegMask
	) begin
		PreReadDataEventMaskReg <= (others => '0');
		PreReadDataEventMaskReg(3 downto 0) <= WRegMask;
	end process;
	
	Mask <= WRegMask;
	
	PreMatchReadEventCatchRegProcess : process (Address, Read)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTCATCHREG_ADDRESS)) then
			PreMatchReadEventCatchReg <= Read;
		else
			PreMatchReadEventCatchReg <= '0';
		end if;
	end process;
	
	PreMatchWriteEventCatchRegProcess : process (Address, Write)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTCATCHREG_ADDRESS)) then
			PreMatchWriteEventCatchReg <= Write;
		else
			PreMatchWriteEventCatchReg <= '0';
		end if;
	end process;
	
	WriteDiffEventCatchRegProcess : process (Address, Write, PreWriteAckEventCatchReg)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTCATCHREG_ADDRESS)) then
			WriteDiffEventCatchReg <=  Write and not PreWriteAckEventCatchReg;
		else
			WriteDiffEventCatchReg <= '0';
		end if;
	end process;
	
	ReadDiffEventCatchRegProcess : process (Address, Read, PreReadAckEventCatchReg)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTCATCHREG_ADDRESS)) then
			ReadDiffEventCatchReg <= Read and not PreReadAckEventCatchReg;
		else
			ReadDiffEventCatchReg <= '0';
		end if;
	end process;
	
	SyncPartEventCatchReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckEventCatchReg <= '0';
			PreWriteAckEventCatchReg <= '0';
		elsif rising_edge(Clk) then
			PreWriteAckEventCatchReg <= WriteDiffEventCatchReg;
			PreReadAckEventCatchReg <= ReadDiffEventCatchReg;
		end if;
	end process;
	
	DataOutPreMuxForEventCatchReg : process (
		CatchToBeRead
	) begin
		PreReadDataEventCatchReg <= (others => '0');
		PreReadDataEventCatchReg(3 downto 0) <= CatchToBeRead;
	end process;
	
	WTransPulseEventCatchReg <= WriteDiffEventCatchReg;
	
	CatchWritten <= WriteData(3 downto 0);
	
	PreMatchReadEventOverrunRegProcess : process (Address, Read)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTOVERRUNREG_ADDRESS)) then
			PreMatchReadEventOverrunReg <= Read;
		else
			PreMatchReadEventOverrunReg <= '0';
		end if;
	end process;
	
	PreMatchWriteEventOverrunRegProcess : process (Address, Write)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTOVERRUNREG_ADDRESS)) then
			PreMatchWriteEventOverrunReg <= Write;
		else
			PreMatchWriteEventOverrunReg <= '0';
		end if;
	end process;
	
	WriteDiffEventOverrunRegProcess : process (Address, Write, PreWriteAckEventOverrunReg)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTOVERRUNREG_ADDRESS)) then
			WriteDiffEventOverrunReg <=  Write and not PreWriteAckEventOverrunReg;
		else
			WriteDiffEventOverrunReg <= '0';
		end if;
	end process;
	
	ReadDiffEventOverrunRegProcess : process (Address, Read, PreReadAckEventOverrunReg)
	begin
		if ((unsigned(Address)/4)*4 = unsigned(EVENTOVERRUNREG_ADDRESS)) then
			ReadDiffEventOverrunReg <= Read and not PreReadAckEventOverrunReg;
		else
			ReadDiffEventOverrunReg <= '0';
		end if;
	end process;
	
	SyncPartEventOverrunReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckEventOverrunReg <= '0';
			PreWriteAckEventOverrunReg <= '0';
		elsif rising_edge(Clk) then
			PreWriteAckEventOverrunReg <= WriteDiffEventOverrunReg;
			PreReadAckEventOverrunReg <= ReadDiffEventOverrunReg;
		end if;
	end process;
	
	DataOutPreMuxForEventOverrunReg : process (
		OverrunToBeRead
	) begin
		PreReadDataEventOverrunReg <= (others => '0');
		PreReadDataEventOverrunReg(3 downto 0) <= OverrunToBeRead;
	end process;
	
	WTransPulseEventOverrunReg <= WriteDiffEventOverrunReg;
	
	OverrunWritten <= WriteData(3 downto 0);
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity EventCatcherIfcBusMonitor is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Read : in  std_logic;
		Write : in  std_logic;
		Match : in std_logic;
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of EventCatcherIfcBusMonitor is

	signal BusAccessDelay : std_logic;
	signal BusAccess : std_logic;
	signal PreUnoccupiedAck : std_logic;
	signal PreTimeoutAck : std_logic;
	signal TimeoutCounter : unsigned(9 downto 0);

begin

	BusAccess <= Read or Write;

	BusAccessDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			BusAccessDelay <= '0';
		elsif rising_edge(Clk) then
			BusAccessDelay <= BusAccess;
		end if;
	end process;

	MatchDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreUnoccupiedAck <= '0';
		elsif rising_edge(Clk) then
			PreUnoccupiedAck <= '0';
			if ((BusAccess = '1') and (BusAccessDelay = '1') and (Match = '0')) then
				PreUnoccupiedAck <= not PreUnoccupiedAck;
			end if;
		end if;
	end process;
	
	TimeoutDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreTimeoutAck <= '0';
			TimeoutCounter <= (others => '1');
		elsif rising_edge(Clk) then
			PreTimeoutAck <= '0';
			TimeoutCounter <= (others => '1');
			if ((BusAccess = '1') and (BusAccessDelay = '1') and (Match = '1')) then
				if (TimeoutCounter = 0) then
					PreTimeoutAck <= not PreTimeoutAck;
				else
					TimeoutCounter <= TimeoutCounter - 1;
				end if;
			end if;
		end if;
	end process;

	UnoccupiedAck <= PreUnoccupiedAck;
	TimeoutAck <= PreTimeoutAck;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.EventCatcherIfcPackage.all;

entity EventCatcherIfcAvalon is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		AvalonDown : in T_EventCatcherIfcAvalonDown;
		AvalonUp : out T_EventCatcherIfcAvalonUp;
		Trace : out T_EventCatcherIfcTrace;
		EventCatcherBlkDown : out T_EventCatcherIfcEventCatcherBlkDown;
		EventCatcherBlkUp : in T_EventCatcherIfcEventCatcherBlkUp
	);
end;

architecture Behavioural of EventCatcherIfcAvalon is

	signal BlockMatch : std_logic;
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal PreAvalonUp : T_EventCatcherIfcAvalonUp;
	
	signal EventCatcherBlkReadData : std_logic_vector(31 downto 0);
	signal EventCatcherBlkWaitRequest : std_logic;
	signal EventCatcherBlkMatch : std_logic;

begin

	i_EventCatcherIfcBusMonitor : entity work.EventCatcherIfcBusMonitor
		port map (
			Clk => Clk,
			Rst => Rst,
			Read => AvalonDown.Read,
			Write => AvalonDown.Write,
			Match => BlockMatch,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_EventCatcherBlk_EventCatcherIfc : entity work.EventCatcherBlk_EventCatcherIfc
		port map (
			Clk => Clk,
			Rst => Rst,
			Address => AvalonDown.Address,
			ByteEnable => AvalonDown.ByteEnable,
			Read => AvalonDown.Read,
			ReadData =>  EventCatcherBlkReadData,
			Write => AvalonDown.Write,
			WriteData => AvalonDown.WriteData,
			WaitRequest => EventCatcherBlkWaitRequest,
			Match => EventCatcherBlkMatch,
			Mask => EventCatcherBlkDown.Mask,
			CatchToBeRead => EventCatcherBlkUp.CatchToBeRead,
			CatchWritten => EventCatcherBlkDown.CatchWritten,
			WTransPulseEventCatchReg => EventCatcherBlkDown.WTransPulseEventCatchReg,
			OverrunToBeRead => EventCatcherBlkUp.OverrunToBeRead,
			OverrunWritten => EventCatcherBlkDown.OverrunWritten,
			WTransPulseEventOverrunReg => EventCatcherBlkDown.WTransPulseEventOverrunReg
		);
	
	Trace.AvalonDown <= AvalonDown;
	Trace.AvalonUp <= PreAvalonUp;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	AvalonUp <= PreAvalonUp;
	
	PreAvalonUp.ReadData <= EventCatcherBlkReadData;
	
	PreAvalonUp.WaitRequest <= EventCatcherBlkWaitRequest
		and not UnoccupiedAck
		and not TimeoutAck;
	
	BlockMatch <= EventCatcherBlkMatch;

end;
